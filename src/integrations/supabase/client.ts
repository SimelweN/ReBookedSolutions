// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

import { ENV } from "@/config/environment";

// Validate Supabase configuration before creating client
const validateSupabaseConfig = () => {
  if (!ENV.VITE_SUPABASE_URL || ENV.VITE_SUPABASE_URL.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_URL is required. Please set this environment variable.",
    );
  }

  if (!ENV.VITE_SUPABASE_ANON_KEY || ENV.VITE_SUPABASE_ANON_KEY.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_ANON_KEY is required. Please set this environment variable.",
    );
  }

  // Basic URL validation
  try {
    new URL(ENV.VITE_SUPABASE_URL);
  } catch {
    throw new Error(
      `Invalid VITE_SUPABASE_URL: "${ENV.VITE_SUPABASE_URL}". Must be a valid URL.`,
    );
  }

  // Validate API key format (should be a JWT token)
  const apiKey = ENV.VITE_SUPABASE_ANON_KEY.replace(/^=+/, "");
  if (!apiKey.startsWith("eyJ")) {
    throw new Error(
      `Invalid VITE_SUPABASE_ANON_KEY format. Should be a JWT token starting with "eyJ".`,
    );
  }
};

// Only validate in browser environment
if (typeof window !== "undefined") {
  try {
    validateSupabaseConfig();
    console.log("✅ Supabase configuration validated");
  } catch (error) {
    console.error("❌ Supabase configuration error:", error);
  }
}

// Clean the API key (remove any leading = signs that might have been added by accident)
const getCleanApiKey = () => ENV.VITE_SUPABASE_ANON_KEY.replace(/^=+/, "");

// Create a FullStory-proof fetch implementation using XMLHttpRequest
const createProtectedFetch = () => {
  return async (
    input: RequestInfo | URL,
    init?: RequestInit,
  ): Promise<Response> => {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const url = typeof input === "string" ? input : input.toString();
      const method = init?.method || "GET";

      xhr.open(method, url);

      // Set headers
      if (init?.headers) {
        const headers = init.headers as Record<string, string>;
        Object.entries(headers).forEach(([key, value]) => {
          xhr.setRequestHeader(key, value);
        });
      }

      xhr.onreadystatechange = () => {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          const headers = new Headers();
          xhr
            .getAllResponseHeaders()
            .split("\r\n")
            .forEach((line) => {
              const [key, value] = line.split(": ");
              if (key && value) {
                headers.set(key, value);
              }
            });

          const response = new Response(xhr.responseText, {
            status: xhr.status,
            statusText: xhr.statusText,
            headers,
          });

          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(response);
          } else {
            console.warn(
              `🌐 Supabase request failed: ${xhr.status} ${xhr.statusText}`,
            );
            resolve(response); // Don't reject, let Supabase handle the error
          }
        }
      };

      xhr.onerror = () => {
        console.warn("🌐 Supabase XMLHttpRequest failed");
        reject(
          new Error(
            "Unable to connect to the server. Please check your internet connection and try again.",
          ),
        );
      };

      xhr.ontimeout = () => {
        reject(new Error("Request timeout. Please try again."));
      };

      xhr.timeout = 30000; // 30 second timeout

      // Send request
      if (init?.body) {
        xhr.send(init.body as any);
      } else {
        xhr.send();
      }
    });
  };
};

// Lazy initialization to avoid immediate execution
let protectedFetch: any = null;
let supabase: any = null;

const initializeSupabase = () => {
  if (supabase) return supabase;

  try {
    if (!protectedFetch) {
      protectedFetch = createProtectedFetch();
    }

    const cleanApiKey = getCleanApiKey();

    if (ENV.VITE_SUPABASE_URL && cleanApiKey) {
      supabase = createClient<Database>(ENV.VITE_SUPABASE_URL, cleanApiKey, {
        auth: {
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true,
          flowType: "pkce",
          debug: import.meta.env.DEV,
        },
        global: {
          // Use XMLHttpRequest-based fetch to completely bypass FullStory
          fetch: protectedFetch,
        },
      });
    } else {
      console.error("❌ Supabase configuration missing - creating mock client");
      // Create a mock client for development
      const createMockQueryBuilder = () => {
        const mockError = {
          message: "Supabase client not configured",
          details:
            "Please configure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY",
          hint: "Run 'node setup-environment.js' to configure",
        };

        return {
          select: () => createMockQueryBuilder(),
          insert: () => createMockQueryBuilder(),
          update: () => createMockQueryBuilder(),
          delete: () => createMockQueryBuilder(),
          upsert: () => createMockQueryBuilder(),
          from: () => createMockQueryBuilder(),
          eq: () => createMockQueryBuilder(),
          neq: () => createMockQueryBuilder(),
          gt: () => createMockQueryBuilder(),
          gte: () => createMockQueryBuilder(),
          lt: () => createMockQueryBuilder(),
          lte: () => createMockQueryBuilder(),
          like: () => createMockQueryBuilder(),
          ilike: () => createMockQueryBuilder(),
          is: () => createMockQueryBuilder(),
          in: () => createMockQueryBuilder(),
          contains: () => createMockQueryBuilder(),
          containedBy: () => createMockQueryBuilder(),
          rangeGt: () => createMockQueryBuilder(),
          rangeGte: () => createMockQueryBuilder(),
          rangeLt: () => createMockQueryBuilder(),
          rangeLte: () => createMockQueryBuilder(),
          rangeAdjacent: () => createMockQueryBuilder(),
          overlaps: () => createMockQueryBuilder(),
          textSearch: () => createMockQueryBuilder(),
          match: () => createMockQueryBuilder(),
          not: () => createMockQueryBuilder(),
          or: () => createMockQueryBuilder(),
          filter: () => createMockQueryBuilder(),
          order: () => createMockQueryBuilder(),
          limit: () => createMockQueryBuilder(),
          range: () => createMockQueryBuilder(),
          abortSignal: () => createMockQueryBuilder(),
          single: () => Promise.resolve({ data: null, error: mockError }),
          maybeSingle: () => Promise.resolve({ data: null, error: mockError }),
          then: () => Promise.resolve({ data: null, error: mockError }),
        };
      };

      supabase = {
        from: () => createMockQueryBuilder(),
        auth: {
          signUp: () => Promise.resolve({ data: null, error: mockError }),
          signInWithPassword: () =>
            Promise.resolve({ data: null, error: mockError }),
          signOut: () => Promise.resolve({ error: null }),
          getSession: () =>
            Promise.resolve({ data: { session: null }, error: null }),
          getUser: () => Promise.resolve({ data: { user: null }, error: null }),
          onAuthStateChange: () => ({
            data: { subscription: { unsubscribe: () => {} } },
          }),
        },
        storage: {
          from: () => ({
            upload: () => Promise.resolve({ data: null, error: mockError }),
            download: () => Promise.resolve({ data: null, error: mockError }),
            getPublicUrl: () => ({ data: { publicUrl: "" } }),
            list: () => Promise.resolve({ data: null, error: mockError }),
            remove: () => Promise.resolve({ data: null, error: mockError }),
          }),
        },
      };
    }

    return supabase;
  } catch (error) {
    console.error("❌ Failed to initialize Supabase client:", error);
    throw error;
  }
};

// Create a getter that initializes on first access
const supabaseProxy = new Proxy(
  {},
  {
    get(target, prop) {
      const client = initializeSupabase();
      return client[prop];
    },
  },
);

export { supabaseProxy as supabase };

// Debug connection on client creation (browser only)
if (import.meta.env.DEV && typeof window !== "undefined") {
  // Delay debug logging to avoid immediate execution
  setTimeout(() => {
    const cleanApiKey = getCleanApiKey();
    console.log(
      "🔗 Supabase client initialized with XMLHttpRequest-based fetch",
    );
    console.log("URL:", ENV.VITE_SUPABASE_URL);
    console.log("Key starts with:", cleanApiKey.substring(0, 20) + "...");
    console.log("✅ Using FullStory-proof XMLHttpRequest implementation");
  }, 0);
}
