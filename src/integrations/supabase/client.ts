// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

import { ENV } from "@/config/environment";

// Validate Supabase configuration before creating client
const validateSupabaseConfig = () => {
  if (!ENV.VITE_SUPABASE_URL || ENV.VITE_SUPABASE_URL.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_URL is required. Please set this environment variable.",
    );
  }

  if (!ENV.VITE_SUPABASE_ANON_KEY || ENV.VITE_SUPABASE_ANON_KEY.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_ANON_KEY is required. Please set this environment variable.",
    );
  }

  // Basic URL validation
  try {
    new URL(ENV.VITE_SUPABASE_URL);
  } catch {
    throw new Error(
      `Invalid VITE_SUPABASE_URL: "${ENV.VITE_SUPABASE_URL}". Must be a valid URL.`,
    );
  }

  // Validate API key format (should be a JWT token)
  if (!ENV.VITE_SUPABASE_ANON_KEY.startsWith("eyJ")) {
    console.error(
      "‚ùå Invalid Supabase API key format. Key should start with 'eyJ'",
    );
    console.error(
      "Current key starts with:",
      ENV.VITE_SUPABASE_ANON_KEY.substring(0, 10),
    );
    throw new Error(
      "Invalid VITE_SUPABASE_ANON_KEY format. Should be a JWT token starting with 'eyJ'.",
    );
  }
};

// Validate configuration with graceful fallback
try {
  validateSupabaseConfig();
} catch (configError) {
  console.warn("‚ö†Ô∏è Supabase configuration issue:", configError);
  // In development, we can continue with limited functionality
  if (import.meta.env.DEV) {
    console.warn(
      "‚ö†Ô∏è Continuing with limited functionality in development mode",
    );
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Clean the API key (remove any leading = signs that might have been added by accident)
const cleanApiKey = ENV.VITE_SUPABASE_ANON_KEY.replace(/^=+/, "");

// Create a FullStory-proof fetch implementation using XMLHttpRequest
const createProtectedFetch = () => {
  return async (
    input: RequestInfo | URL,
    init?: RequestInit,
  ): Promise<Response> => {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const url = typeof input === "string" ? input : input.toString();
      const method = init?.method || "GET";

      xhr.open(method, url);

      // Set headers
      if (init?.headers) {
        const headers = new Headers(init.headers);
        headers.forEach((value, key) => {
          xhr.setRequestHeader(key, value);
        });
      }

      // Handle response
      xhr.onload = () => {
        const headers: Record<string, string> = {};
        xhr
          .getAllResponseHeaders()
          .split("\r\n")
          .forEach((line) => {
            const [key, value] = line.split(": ");
            if (key && value) headers[key] = value;
          });

        // Handle responses that shouldn't have a body
        const statusWithoutBody = [204, 205, 304];
        const responseBody = statusWithoutBody.includes(xhr.status)
          ? null
          : xhr.responseText;

        const response = new Response(responseBody, {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: new Headers(headers),
        });

        resolve(response);
      };

      xhr.onerror = () => {
        console.warn("üåê Supabase XMLHttpRequest failed");
        reject(
          new Error(
            "Unable to connect to the server. Please check your internet connection and try again.",
          ),
        );
      };

      xhr.ontimeout = () => {
        reject(new Error("Request timeout. Please try again."));
      };

      xhr.timeout = 30000; // 30 second timeout

      // Send request
      if (init?.body) {
        xhr.send(init.body as any);
      } else {
        xhr.send();
      }
    });
  };
};

const protectedFetch = createProtectedFetch();

// Only create Supabase client if we have valid configuration
let supabase: any;

try {
  if (ENV.VITE_SUPABASE_URL && cleanApiKey) {
    supabase = createClient<Database>(ENV.VITE_SUPABASE_URL, cleanApiKey, {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true,
        flowType: "pkce",
        debug: import.meta.env.DEV,
      },
      global: {
        // Use XMLHttpRequest-based fetch to completely bypass FullStory
        fetch: protectedFetch,
      },
    });
  } else {
    console.error("‚ùå Supabase configuration missing - creating mock client");
    // Create a mock client for development
    supabase = {
      auth: {
        signUp: () => Promise.reject(new Error("Supabase not configured")),
        signInWithPassword: () =>
          Promise.reject(new Error("Supabase not configured")),
        signOut: () => Promise.reject(new Error("Supabase not configured")),
        getSession: () =>
          Promise.resolve({ data: { session: null }, error: null }),
        onAuthStateChange: () => ({
          data: { subscription: { unsubscribe: () => {} } },
        }),
      },
      from: () => ({
        select: () => Promise.reject(new Error("Supabase not configured")),
        insert: () => Promise.reject(new Error("Supabase not configured")),
        update: () => Promise.reject(new Error("Supabase not configured")),
        delete: () => Promise.reject(new Error("Supabase not configured")),
      }),
      functions: {
        invoke: () => Promise.reject(new Error("Supabase not configured")),
      },
    };
  }
} catch (error) {
  console.error("‚ùå Failed to initialize Supabase client:", error);
  throw error;
}

export { supabase };

// Debug connection on client creation
if (import.meta.env.DEV) {
  console.log("üîó Supabase client initialized with XMLHttpRequest-based fetch");
  console.log("URL:", ENV.VITE_SUPABASE_URL);
  console.log("Key starts with:", cleanApiKey.substring(0, 20) + "...");
  console.log("‚úÖ Using FullStory-proof XMLHttpRequest implementation");
}
