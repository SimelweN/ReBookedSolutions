// This file is automatically generated. Do not edit it directly.
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

import { ENV } from "@/config/environment";

// Validate Supabase configuration before creating client
const validateSupabaseConfig = () => {
  if (!ENV.VITE_SUPABASE_URL || ENV.VITE_SUPABASE_URL.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_URL is required. Please set this environment variable.",
    );
  }

  if (!ENV.VITE_SUPABASE_ANON_KEY || ENV.VITE_SUPABASE_ANON_KEY.trim() === "") {
    throw new Error(
      "VITE_SUPABASE_ANON_KEY is required. Please set this environment variable.",
    );
  }

  // Basic URL validation
  try {
    new URL(ENV.VITE_SUPABASE_URL);
  } catch {
    throw new Error(
      `Invalid VITE_SUPABASE_URL: "${ENV.VITE_SUPABASE_URL}". Must be a valid URL.`,
    );
  }

  // Validate API key format (should be a JWT token)
  if (!ENV.VITE_SUPABASE_ANON_KEY.startsWith("eyJ")) {
    console.error(
      "‚ùå Invalid Supabase API key format. Key should start with 'eyJ'",
    );
    console.error(
      "Current key starts with:",
      ENV.VITE_SUPABASE_ANON_KEY.substring(0, 10),
    );
    throw new Error(
      "Invalid VITE_SUPABASE_ANON_KEY format. Should be a JWT token starting with 'eyJ'.",
    );
  }
};

// Validate configuration with graceful fallback (only in browser)
if (typeof window !== "undefined") {
  try {
    validateSupabaseConfig();
  } catch (configError) {
    console.warn("‚ö†Ô∏è Supabase configuration issue:", configError);
    // In development, we can continue with limited functionality
    if (import.meta.env.DEV) {
      console.warn(
        "‚ö†Ô∏è Continuing with limited functionality in development mode",
      );
    }
  }
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Clean the API key (remove any leading = signs that might have been added by accident)
const cleanApiKey = ENV.VITE_SUPABASE_ANON_KEY.replace(/^=+/, "");

// Create a FullStory-proof fetch implementation using XMLHttpRequest
const createProtectedFetch = () => {
  return async (
    input: RequestInfo | URL,
    init?: RequestInit,
  ): Promise<Response> => {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      const url = typeof input === "string" ? input : input.toString();
      const method = init?.method || "GET";

      xhr.open(method, url);

      // Set headers
      if (init?.headers) {
        const headers = new Headers(init.headers);
        headers.forEach((value, key) => {
          xhr.setRequestHeader(key, value);
        });
      }

      // Handle response
      xhr.onload = () => {
        const headers: Record<string, string> = {};
        xhr
          .getAllResponseHeaders()
          .split("\r\n")
          .forEach((line) => {
            const [key, value] = line.split(": ");
            if (key && value) headers[key] = value;
          });

        // Handle responses that shouldn't have a body
        const statusWithoutBody = [204, 205, 304];
        const responseBody = statusWithoutBody.includes(xhr.status)
          ? null
          : xhr.responseText;

        const response = new Response(responseBody, {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: new Headers(headers),
        });

        resolve(response);
      };

      xhr.onerror = () => {
        console.warn("üåê Supabase XMLHttpRequest failed");
        reject(
          new Error(
            "Unable to connect to the server. Please check your internet connection and try again.",
          ),
        );
      };

      xhr.ontimeout = () => {
        reject(new Error("Request timeout. Please try again."));
      };

      xhr.timeout = 30000; // 30 second timeout

      // Send request
      if (init?.body) {
        xhr.send(init.body as any);
      } else {
        xhr.send();
      }
    });
  };
};

const protectedFetch = createProtectedFetch();

// Only create Supabase client if we have valid configuration
let supabase: any;

try {
  if (ENV.VITE_SUPABASE_URL && cleanApiKey) {
    supabase = createClient<Database>(ENV.VITE_SUPABASE_URL, cleanApiKey, {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true,
        flowType: "pkce",
        debug: import.meta.env.DEV,
      },
      global: {
        // Use XMLHttpRequest-based fetch to completely bypass FullStory
        fetch: protectedFetch,
      },
    });
  } else {
    console.error("‚ùå Supabase configuration missing - creating mock client");
    // Create a mock client for development
    const createMockQueryBuilder = () => {
      const mockError = {
        message:
          "Supabase not configured - please set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY environment variables",
        code: "SUPABASE_NOT_CONFIGURED",
      };
      const mockResponse = { data: null, error: mockError };
      const mockPromise = Promise.resolve(mockResponse);

      const mockQuery = {
        select: () => mockQuery,
        insert: () => mockQuery,
        update: () => mockQuery,
        delete: () => mockQuery,
        limit: () => mockQuery,
        single: () => mockQuery,
        range: () => mockQuery,
        order: () => mockQuery,
        filter: () => mockQuery,
        eq: () => mockQuery,
        neq: () => mockQuery,
        gt: () => mockQuery,
        gte: () => mockQuery,
        lt: () => mockQuery,
        lte: () => mockQuery,
        like: () => mockQuery,
        ilike: () => mockQuery,
        is: () => mockQuery,
        in: () => mockQuery,
        contains: () => mockQuery,
        containedBy: () => mockQuery,
        rangeGt: () => mockQuery,
        rangeGte: () => mockQuery,
        rangeLt: () => mockQuery,
        rangeLte: () => mockQuery,
        rangeAdjacent: () => mockQuery,
        overlaps: () => mockQuery,
        textSearch: () => mockQuery,
        match: () => mockQuery,
        not: () => mockQuery,
        or: () => mockQuery,
        then: (onFulfilled?: any, onRejected?: any) =>
          mockPromise.then(onFulfilled, onRejected),
        catch: (onRejected?: any) => mockPromise.catch(onRejected),
        finally: (onFinally?: any) => mockPromise.finally(onFinally),
        // Make it awaitable
        [Symbol.toStringTag]: "Promise",
      };

      // Make the query builder await-able
      Object.setPrototypeOf(mockQuery, Promise.prototype);

      return mockQuery;
    };

    const mockError = {
      message:
        "Supabase not configured - please set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY environment variables",
      code: "SUPABASE_NOT_CONFIGURED",
    };

    supabase = {
      auth: {
        signUp: () =>
          Promise.resolve({
            data: { user: null, session: null },
            error: mockError,
          }),
        signInWithPassword: () =>
          Promise.resolve({
            data: { user: null, session: null },
            error: mockError,
          }),
        signOut: () => Promise.resolve({ error: mockError }),
        getSession: () =>
          Promise.resolve({ data: { session: null }, error: null }),
        onAuthStateChange: () => ({
          data: { subscription: { unsubscribe: () => {} } },
        }),
        getUser: () =>
          Promise.resolve({ data: { user: null }, error: mockError }),
        refreshSession: () =>
          Promise.resolve({
            data: { user: null, session: null },
            error: mockError,
          }),
        updateUser: () =>
          Promise.resolve({ data: { user: null }, error: mockError }),
        resetPasswordForEmail: () =>
          Promise.resolve({ data: {}, error: mockError }),
      },
      from: () => createMockQueryBuilder(),
      functions: {
        invoke: () => Promise.resolve({ data: null, error: mockError }),
      },
      storage: {
        from: () => ({
          upload: () => Promise.resolve({ data: null, error: mockError }),
          download: () => Promise.resolve({ data: null, error: mockError }),
          list: () => Promise.resolve({ data: null, error: mockError }),
          remove: () => Promise.resolve({ data: null, error: mockError }),
        }),
      },
    };
  }
} catch (error) {
  console.error("‚ùå Failed to initialize Supabase client:", error);
  throw error;
}

export { supabase };

// Debug connection on client creation (browser only)
if (import.meta.env.DEV && typeof window !== "undefined") {
  console.log("üîó Supabase client initialized with XMLHttpRequest-based fetch");
  console.log("URL:", ENV.VITE_SUPABASE_URL);
  console.log("Key starts with:", cleanApiKey.substring(0, 20) + "...");
  console.log("‚úÖ Using FullStory-proof XMLHttpRequest implementation");
}
